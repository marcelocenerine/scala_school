---
layout: post
title: Básico
next: basics2.textile
---

Essa lição cobre:
* "Sobre essa aula":#overview
* "expressões":#expressions
* "valores":#val
* "funções":#functions
* "classes":#class
* "herança básica":#extends
* "traits":#trait
* "tipos":#types

h2(#overview). Sobre essa aula

Nas primeiras semanas iremos cobrir sintaxe e conceitos básicos, na sequência iremos avançar com mais exercícios.

Alguns exemplos serão apresentados como se tivessem sido escritos no interpretador e outros como em arquivo fonte.

Ter um interpretador disponível torna fácil explorar um determinado problema.

h3. Por que Scala?

* Expressivo
** Funções de primeira-classe
** Closures
* Conciso
** Inferência de tipo
** Sintaxe literal para criação de funções
* Interoperabilidade com o Java
** Utilizar bibliotecas do java
** Utilizar ferramentas do java
** Sem perca de performance

h3. Jeito Scala?

* Compila em bytecode do java
* Funciona com qualquer JVM padrão
** Ou mesmo com JVMs não padrão como Dalvik
** Compilador do Scala escrito pelo autor do compilador Java

h3. Pense em Scala

Scala não é apenas um Java melhorado. Você deve aprende-lo com a mente aberta - você irá aproveitar mais das aulas dessa forma.

h3. Obtenha Scala

Os exemplos da Escola Scala funcionam com "Scala 2.9.x":http://www.scala-lang.org/download/2.9.3.html . Se você usar Scala 2.10.x ou superior, _a maior parte_ dos exemplos irão funcionar, mas não todos.

h3. Iniciando o Interpretador

Inicie o console sbt com o comando <code>sbt console</code>.

<pre>
$ sbt console

[...]

Welcome to Scala version 2.8.0.final (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_20).
Type in expressions to have them evaluated.
Type :help for more information.

scala>
</pre>


h2(#expressions). Expressões

<pre>
scala> 1 + 1
res0: Int = 2
</pre>

res0 é um nome criado automaticamente pelo interpretador para o valor da sua expressão. Ele é do tipo Int e contém um o número inteiro 2.

(Quase) tudo em Scala é uma expressão.

h2(#val). Valores

Você pode dar um nome ao resultado de uma expressão.

<pre>
scala> val two = 1 + 1
two: Int = 2
</pre>

Você não pode mudar a referência de um val.

h3. Variáveis

Se você precisa mudar a referência, você pode usar um <code>var</code>.

<pre>
scala> var name = "steve"
name: java.lang.String = steve

scala> name = "marius"
name: java.lang.String = marius
</pre>

h2(#functions). Funções

Você pode criar uma função utilizando def.

<pre>
scala> def addOne(m: Int): Int = m + 1
addOne: (m: Int)Int
</pre>

Em Scala, você precisa definir o tipo dos parâmetros da assinatura de um função. O interpretador repete o tipo dos parâmetros da assinatura de volta para você.

<pre>
scala> val three = addOne(2)
three: Int = 3
</pre>

Você pode omitir os parênteses em funções sem argumentos.

<pre>
scala> def three() = 1 + 2
three: ()Int

scala> three()
res2: Int = 3

scala> three
res3: Int = 3
</pre>

h3. Funções Anônimas

Você pode criar funções anônimas.

<pre>
scala> (x: Int) => x + 1
res2: (Int) => Int = <function1>
</pre>

Essa função adiciona 1 a um Int chamado x.

<pre>
scala> res2(1)
res3: Int = 2
</pre>

Você pode passar funções anônimas para outras funções ou salvá-las em vals.

<pre>
scala> val addOne = (x: Int) => x + 1
addOne: (Int) => Int = <function1>

scala> addOne(1)
res4: Int = 2
</pre>

Se a sua função é formada por muitas expressões, você pode usar {} para te dar espaço.

<pre>
def timesTwo(i: Int): Int = {
  println("hello world")
  i * 2
}
</pre>

Isso também vale para funções anônimas.

<pre>
scala> { i: Int =>
  println("hello world")
  i * 2
}
res0: (Int) => Int = <function1>
</pre>

Você verá essa sintaxe frequentemente quando funções são passadas como argumentos para outras funções.

h3. Aplicação parcial (Partial application)

Você pode aplicar uma função parcialmente com um underscore, isso lhe dá uma outra função. Em Scala, o underscore tem diferentes significados em diferentes contextos, você pode pensar nele como um carácter curinga mágico. Em <code>{ _ + 2 }</code> ele significa um parâmetro não nomeado. Você pode utilizá-lo dessa forma:

<pre>
scala> def adder(m: Int, n: Int) = m + n
adder: (m: Int,n: Int)Int
</pre>

<pre>
scala> val add2 = adder(2, _:Int)
add2: (Int) => Int = <function1>

scala> add2(3)
res50: Int = 5
</pre>

Você pode aplicar parcialmente qualquer argumento de uma função, não apenas o último.

h3. Funções Curried (Curried functions)

Algumas vezes faz sentido deixar que alguns argumentos da sua função sejam aplicados agora e outros depois.

Esse é um exemplo de uma função que permite multiplicar dois números. Na primeira chamada, você decide qual é o multiplicador e em uma chamada posterior, você decide o multiplicando.

<pre>
scala> def multiply(m: Int)(n: Int): Int = m * n
multiply: (m: Int)(n: Int)Int
</pre>

Você pode chamar a função diretamente com os dois argumentos.

<pre>
scala> multiply(2)(3)
res0: Int = 6
</pre>

Você pode informar o primeiro parâmetro e aplicar parcialmente o segundo.

<pre>
scala> val timesTwo = multiply(2) _
timesTwo: (Int) => Int = <function1>

scala> timesTwo(3)
res1: Int = 6
</pre>

You can take any function of multiple arguments and curry it. Let's try with our earlier <code>adder</code>
Você pode utilizar a técnica curry com qualquer função que possua múltiplos argumentos. Vamos tentar com a nossa função anterior <code>adder</code>

<pre>
scala> val curriedAdd = (adder _).curried
curriedAdd: Int => (Int => Int) = <function1>

scala> val addTwo = curriedAdd(2)
addTwo: Int => Int = <function1>

scala> addTwo(4)
res22: Int = 6
</pre>

h3. Número variável de argumentos

Existe uma sintaxe especial para métodos que recebem parâmetros repetidos de um mesmo tipo. Para aplicar a função <code>capitalize</code> a várias strings, você pode escrever:

<pre>
def capitalizeAll(args: String*) = {
  args.map { arg =>
    arg.capitalize
  }
}

scala> capitalizeAll("rarity", "applejack")
res2: Seq[String] = ArrayBuffer(Rarity, Applejack)
</pre>

h2(#class). Classes

<pre>
scala> class Calculator {
     |   val brand: String = "HP"
     |   def add(m: Int, n: Int): Int = m + n
     | }
defined class Calculator

scala> val calc = new Calculator
calc: Calculator = Calculator@e75a11

scala> calc.add(1, 2)
res1: Int = 3

scala> calc.brand
res2: String = "HP"
</pre>

São apresentados exemplos definindo métodos com def e atributos com val. Métodos são apenas funções que podem acessar o estado de uma classe.

h3. Construtores

Construtores não são métodos especiais, eles são o código fora dos métodos na sua classe. Vamos alterar a nossa classe Calculadora para receber um argumento no construtor e usá-lo para inicializar um estado interno.

<pre>
class Calculator(brand: String) {
  /**
   * A constructor.
   */
  val color: String = if (brand == "TI") {
    "blue"
  } else if (brand == "HP") {
    "black"
  } else {
    "white"
  }

  // An instance method.
  def add(m: Int, n: Int): Int = m + n
}
</pre>

Note os dois diferentes tipos de comentário.

Você pode usar o construtor para construir instâncias:

<pre>
scala> val calc = new Calculator("HP")
calc: Calculator = Calculator@1e64cc4d

scala> calc.color
res0: String = black
</pre>

h3. Expressões

Nossa class Calculadora é um exemplo de como Scala é orientado a expressão. O valor color foi atribuído com base na expressão if/else. Scala é altamente orientado a expressão: a maior parte das coisas são expressões ao invés de instruções.

h3. Aside: Funções x Métodos

Funções e métodos são bastante intercambiáveis. Por funções e métodos serem tão parecidos, você pode não lembrar se a <em>coisa</em> que você chama é uma função ou um método. Você pode se confundir quando se deparar com uma diferença entre métodos e funções.

<pre>
scala> class C {
     |   var acc = 0
     |   def minc = { acc += 1 }
     |   val finc = { () => acc += 1 }
     | }
defined class C

scala> val c = new C
c: C = C@1af1bd6

scala> c.minc // calls c.minc()

scala> c.finc // returns the function as a value:
res2: () => Unit = <function0>
</pre>

Quando você chama uma "função" sem parênteses e outra com, vou pode pensar, <em>Ops, eu pensei que eu sabia como funções funcionavam em Scala, mas eu acho que não. Talvez funções as vezes precisem de parâmetros?</em> Você pode entender funções, mas estar usando um método.

Na prática, você pode fazer várias coisas em Scala sem perceber a diferença entre métodos e funções. Se você é novo em Scala e ler as <a href="https://www.google.com/search?q=difference+scala+function+method">explicações das diferenças</a>, você pode ter problema ao tentar segui-las. Isso não significa que você vai ter problem ao usar Scala. Isso apenas significa que as diferenças entre funções e métodos são sutis o bastante que explicações sobre as diferenças vão mais a fundo em partes da linguagem.

h2(#extends). Herança

<pre>
class ScientificCalculator(brand: String) extends Calculator(brand) {
  def log(m: Double, base: Double) = math.log(m) / math.log(base)
}
</pre>

*Veja também* Pontos em Scala Efetivo em que <a href="http://twitter.github.com/effectivescala/#Types%20and%20Generics-Type%20aliases">Apelido de tipo (Type alias)</a> é melhor que <code>extends</code> se a classe não é na verdade diferente da super classe. O Tour do Scala descreve a técnica de <a href="http://www.scala-lang.org/node/125">subclasse</a>.

h3. Sobrecarga de métodos

<pre>
class EvenMoreScientificCalculator(brand: String) extends ScientificCalculator(brand) {
  def log(m: Int): Double = log(m, math.exp(1))
}
</pre>

h3. Classes abstratas

Você pode definir classe abstratas, <em>abstract class</em>, classes que definem alguns métodos, mas não a sua implementação. Ao invés disso, classes que extendem a classe abstrata implementam esses métodos. Você não pode criar uma instância de uma classe abstrata.

<pre>
scala> abstract class Shape {
     |   def getArea():Int    // subclass should define this
     | }
defined class Shape

scala> class Circle(r: Int) extends Shape {
     |   def getArea():Int = { r * r * 3 }
     | }
defined class Circle

scala> val s = new Shape
<console>:8: error: class Shape is abstract; cannot be instantiated
       val s = new Shape
               ^

scala> val c = new Circle(2)
c: Circle = Circle@65c0035b
</pre>

h2(#trait). Traits

<code>traits</code> são coleções de atributos e comportamentos que você pode extender ou misturar (_mixin_) na sua classe.

<pre>
trait Car {
  val brand: String
}

trait Shiny {
  val shineRefraction: Int
}
</pre>

<pre>
class BMW extends Car {
  val brand = "BMW"
}
</pre>

Uma classe pode extender várias traits usando a palavra-chave <code>with</code>:

<pre>
class BMW extends Car with Shiny {
  val brand = "BMW"
  val shineRefraction = 12
}
</pre>

*Veja também* Scala Efetivo tem opiniões sobre <a href="http://twitter.github.com/effectivescala/#Object oriented programming-Traits">Traits</a>.

*Quando usar uma Trait ao invés de uma Classe abstrata?* Se você quer definir um tipo parecido com interfaces, você pode achar difícil escolher entre trait e classe abstrata. Qualquer um permite que você defina um tipo com algum comportamento, deixando que subclasses implementem outros comportamentos. Algumas regras:

<ul>
<li>De preferência a traits. É útil que uma classe possa extender várias traits; um classe só pode extender de uma outra classe.
<li>Se você precisa de parâmetros no construtor, use uma classe abstrata. Construtores de classes abstratas podem receber parâmetros; construtores de trais não. Por exemplo, você não pode dizer <code>trait t(i: Int) {}</code>; o parâmetro <code>i</code> é ilegal.
</ul>

Você não é a primeira pessoa a fazer essa pergunta. Veja respostas mais completas em "Scala Traits x classes abstratas":http://stackoverflow.com/questions/1991042/scala-traits-vs-abstract-classes, "Diferenças entre classes abstratas e Traits":http://stackoverflow.com/questions/2005681/difference-between-abstract-class-and-trait e "Programando em Scala: Traits, usar ou não usar?":http://www.artima.com/pins1ed/traits.html#12.7

h2(#types). Tipos

Anteriormente, você viu que nós definimos uma função que recebeu um <code>Int</code> que é um tipo de número. Funções também podem ser genéricas e funcionar com qualquer tipo. Quando isso ocorre, você verá parâmetros de tipo entre colchetes. Esse é um exemplo de um Cache genérico de Chaves e Valores.

<pre>
trait Cache[K, V] {
  def get(key: K): V
  def put(key: K, value: V)
  def delete(key: K)
}
</pre>

Métodos também pode ter parâmetros de tipo.

<pre>
def remove[K](key: K)
</pre>
